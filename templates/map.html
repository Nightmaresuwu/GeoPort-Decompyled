<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">

<head>
    <title>GeoPort</title>

    <script src="https://cdn.jsdelivr.net/npm/babel-polyfill@latest/dist/polyfill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-providers@2.0.0/leaflet-providers.min.js"></script>
    <script src="https://unpkg.com/leaflet-geosearch@3.0.0/dist/geosearch.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/leaflet-geojson-export@2.1.1/dist/leaflet-geojson-export.min.js"></script> -->
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-filelayer@1.2.0/src/leaflet.filelayer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2.4.0/src/easy-button.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.0.0/dist/geosearch.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
    <link href="https://cdn.jsdelivr.net/npm/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.css" rel="stylesheet">
    <link href="https://cdn.lineicons.com/4.0/lineicons.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2.4.0/src/easy-button.min.css" rel="stylesheet">


    <style>
.leaflet-menu {
    display: none;
    position: absolute;
    box-shadow: 0 1px 7px rgba(0,0,0,.4);
    -webkit-border-radius: 4px;
    border-radius: 4px;
    padding: 4px 0;
    background-color: #fff;
    cursor: default;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    z-index: 1001
}

.leaflet-menu a.leaflet-menu-item {
    display: block;
    color: #222;
    font-size: 12px;
    line-height: 20px;
    text-decoration: none;
    padding: 0 12px;
    border-top: 1px solid transparent;
    border-bottom: 1px solid transparent;
    cursor: default;
    outline: 0
}

.leaflet-menu a.leaflet-menu-item.over {
    background-color: #f4f4f4;
    border-top: 1px solid #f0f0f0;
    border-bottom: 1px solid #f0f0f0
}

.leaflet-menu-icon {
    margin: 2px 8px 0 0;
    width: 16px;
    height: 16px;
    float: left;
    border: 0
}
        
        #map {
            width: 100%;
            height: 500px;
            max-height: 70vh;
        }

        .coordinates-container {
            margin-top: 10px;
        }

        /* Dark mode styles */
        body.dark-mode {
            background-color: #222; /* Darker background color for main page */
            color: #fff;
        }


        body.dark-mode div[class="p-3 px-md-4 mb-3 bg-white border-bottom box-shadow"],
        body.dark-mode select[class="custom-select"],
        body.dark-mode select[class="custom-select d-block w-100"],
        body.dark-mode input[type="option"],
        body.dark-mode input[class="form-control"],
        body.dark-mode #border,
        body.dark-mode .collapse textarea,
        body.dark-mode textarea {
            background-color: #333; /* Dark background color for text inputs in dark mode */
            color: #fff; /* Light text color for text inputs in dark mode */
            border-color: #666; /* Dark border color for text inputs in dark mode */
        }

body.dark-mode #border.dark-mode-bg {
        background-color: #222; /* Darker background color for main page in dark mode */
        border-color: #666; /* Dark border color for the container in dark mode */
    }

    body.dark-mode #border.dark-mode-bg .box-shadow {
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); /* Dark shadow for the container in dark mode */
    }

    /* Dark mode toast styles */
body.dark-mode .toast {
    background-color: #333; /* Dark background color for toast */
    color: #fff; /* Light text color for toast in dark mode */
}

body.dark-mode .toast-header {
    background-color: #555; /* Dark background color for toast header */
    color: #fff; /* Light text color for toast header in dark mode */
}

body.dark-mode .toast-header .close {
    color: #fff; /* Light close icon color for toast in dark mode */
}

body.dark-mode .toast-body {
    background-color: #333; /* Dark background color for toast body */
    color: #fff; /* Light text color for toast body in dark mode */
}
/* Dark mode modal styles */
body.dark-mode .modal-content {
    background-color: #333; /* Dark background color for modal content */
    color: #fff; /* Light text color for modal content in dark mode */
}

body.dark-mode .modal-header {
    background-color: #555; /* Dark background color for modal header */
    color: #fff; /* Light text color for modal header in dark mode */
    border-bottom: 1px solid #666; /* Dark border color for modal header in dark mode */
}

body.dark-mode .modal-body {
    background-color: #333; /* Dark background color for modal body */
    color: #fff; /* Light text color for modal body in dark mode */
}

body.dark-mode .modal-footer {
    background-color: #333; /* Dark background color for modal footer */
    color: #fff; /* Light text color for modal footer in dark mode */
    border-top: 1px solid #666; /* Dark border color for modal footer in dark mode */
}

body.dark-mode .modal-header .close {
    color: #fff; /* Light close icon color for modal in dark mode */
}

body.dark-mode .modal-footer button {
    color: #fff; /* Light button text color for modal footer in dark mode */
    background-color: #555; /* Dark button background color for modal footer in dark mode */
    border-color: #555; /* Dark border color for buttons in modal footer in dark mode */
}
.marker-menu {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 5px;
    padding: 10px;
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.menu-item {
    background-color: #f8f9fa;
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s;
}

.menu-item:hover {
    background-color: #e9ecef;
}
/* Adjust the styling of the custom button to remove any outlines */
.leaflet-control-filelayer .leaflet-control-filelayer-custom {
    outline: none !important; /* Remove any outline */
    border: none !important; /* Remove any border */
    box-shadow: none !important; /* Remove any box-shadow */
}

/* Add margin to each button except for the last one */
.leaflet-control-filelayer-custom {
    margin-bottom: 1px; /* Adjust the margin as needed */
}

/* Remove margin from the last button */
.leaflet-control-filelayer-custom:first-child {
    margin-top: 1px;
}

/* Add a bottom border to each button except for the last one */
.leaflet-control-filelayer-custom:not(:last-child) {
    border-bottom: 1px solid gray;
}
.leaflet-control-filelayer .leaflet-control-send-gpx1 {
    outline: none !important; /* Remove any outline */
    border: none !important; /* Remove any border */
    box-shadow: none !important; /* Remove any box-shadow */
}*/
.custom-popup-content {
        width: 300px; /* Adjust the width as needed */
    }
.time-to-next-point-control-container {
    position: absolute;
    bottom: 10px;
    left: 10px;
}
/* Hide EasyButton containers */
.leaflet-bar.easy-button-container.leaflet-control {
    display: none;
}
/* Custom CSS to make layer control button smaller */
.leaflet-control-layers-toggle {
    width: 10px; /* Adjust width as needed */
    height: 10px; /* Adjust height as needed */
    font-size: 8px; /* Adjust font size as needed */
    padding: 4px; /* Adjust padding as needed */
}

    </style>
</head>

<body>
  {% if version_message %}
        <div class="alert alert-warning" role="alert">
            {{ version_message }}
        </div>
    {% endif %}

  {% if github_broadcast %}
    <div class="alert alert-info" role="alert">
        {{ github_broadcast }}
    </div>
    {% endif %}

{% if timeout_message %}
        <div class="alert alert-warning" role="alert">
            {{ timeout_message }}
        </div>
    {% endif %}
    {% if error_message %}
        <div class="alert alert-danger" role="alert">
            {{ error_message }}
        </div>
    {% endif %}
<p><br></p>

<div class="d-flex flex-column align-items-center flex-md-row container">
    <h4 class="my-0 mx-auto font-weight-normal">GeoPort - Your location, Anywhere!</h4>
    <a id="about-btn" class="btn btn-outline-primary pl-4 pr-4" href="#" title="GeoPort" style="display: none;">About</a>
    <a id="exit-btn" class="btn btn-outline-primary pl-4 pr-4 ml-4" href="#" title="GeoPort" onclick="exitApp()">Exit</a>
</div>



<!-- Dark Mode switch -->
<div class="d-flex justify-content-md-end mt-3 container">
    <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" role="switch" id="darkModeSwitch" onchange="toggleDarkMode()">
        <label class="form-check-label" for="darkModeSwitch">Dark Mode</label>

    </div>
</div>
<div class="d-flex justify-content-md-end mt-3 container">
    <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="enableFuelPrices" onchange="toggleFuelTypeVisibility()">
            <label for="enableFuelPrices"> Fuel Mode</label>
    </div>
</div>



<div class="container">
<!--    <div class="p-3 px-md-4 mb-3 bg-white border-bottom box-shadow dark-mode-bg"  id="border">-->
    <div class="p-3 px-md-4 mb-3 border-bottom box-shadow dark-mode-bg"  id="border">

</div>


	<!-- Connect Device -->
{% if error_messages %}
    <button type="button" class="btn btn-primary pl-4 pr-4" id="connect" onclick="connectDevice()" disabled>
        <span id="connectText">Connect Device</span>
    </button>
{% else %}
    <br>
      <form>
    <div class="mb-3">
        <label for="device">Select Device:</label><br>
        <div class="row">
            <div class="col">
                <select class="custom-select d-block w-100" id="device" required>
                </select>
            </div>
            <div class="col-md-auto">
                <button type="button" class="btn btn-primary pl-4 pr-4" id="refresh" onclick="populateDeviceList()">Refresh</button>
            </div>
        </div>
    </div>
</form>



    <!-- Keeping this code for the connection details drop down list, but hiding it. Not really required, but handy for debugging -->
<div class="mb-3" style="display: none;">
    <label for="connection">Connection:</label><br>
    <div class="row">
        <div class="col">
            <select class="custom-select d-block w-100" id="connection" required>
            </select>
        </div>
    </div>
</div>

<button type="button" class="btn btn-primary pl-4 pr-4" id="connect" onclick="connectDevice()">
    <span id="connectText">Connect Device</span>
    <span id="spinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;"></span>
</button>

<button type="button" class="btn btn-danger pl-4 pr-4" id="disconnect" onclick="disconnectDevice()" style="display: none;">
    Disconnect
</button>


    <!-- Add this input element with ID "rsdData" -->
<input class="form-control" type="text" id="rsdData" placeholder="RSD Data…" readonly style="display: none;">  <!-- Initially hidden -->

{% endif %}

<p></p>
    <form>
<!-- Not implemented in standard version -->
<!--<div class="mb-3">-->
<!--        <input type="checkbox" role="switch" id="enableFuelPrices" onchange="toggleFuelTypeVisibility()" checked>-->
<!--        <label for="enableFuelPrices"> Enable best fuel prices (Australia only)</label>-->
<!--    </div>-->

<!--     Fuel Region Dropdown -->
    <div class="mb-3" id="fuelRegionSection" style="display: none;">
    <label for="fuelRegion">Select Region:</label>
    <select class="custom-select" id="fuelRegion" onchange="handleFuelTypeChange()">
        <option value="All">All</option>
        <option value="ACT">ACT</option>
        <option value="NSW">NSW</option>
        <option value="QLD">QLD</option>
        <option value="VIC">VIC</option>
        <option value="WA">WA</option>
    </select>
</div>
        <!--     Fuel Type Dropdown -->
    <div class="mb-3" id="fuelTypeSection" style="display: none;">
        <label for="fuelType">Select fuel type:</label>
        <select class="custom-select" id="fuelType" onchange="handleFuelTypeChange()">
            <!-- Options will be populated dynamically -->
        </select>
        <p></p>
        <div class="form-group">
            <div class="collapse" id="fuelDataCollapse">
                <label for="fuelText">Fuel Data</label>
                <textarea class="form-control" id="fuelText" rows="8" readonly disabled></textarea>
            </div>
        </div>
    </div>

	<div id="dataList" class="mb-3"></div>
        </form>
	<div id="map"></div>

<script>
//=========================== leaflet menu ====================
L.Control.LeafletMenu = L.Control.extend({
    options: {
        mapId: "map",
        items: [],
        button: void 0
    },
    statics: {
        CLASS: "leaflet-menu",
        OverFlow_Y: "overflow-y",
        OverFlow_X: "overflow-x"
    },
    initialize: function(a, b) {
        L.setOptions(this, b),
        this.map = a,
        this.menuItem = [],
        this.menu_div = L.DomUtil.create("div", "menu", document.getElementById(this.options.mapId)),
        this.container(),
        L.DomEvent.on(this.container, "click", this._onMouseClick, this).on(this.container, "mouseover", this._onMouseOver, this).on(this.container, "mouseout", this._onMouseOut, this).on(this.container, "mousewheel", L.DomEvent.stop).on(this.container, "mousedown", L.DomEvent.stop).on(this.container, "dblclick", L.DomEvent.stop).on(this.container, "contextmenu", L.DomEvent.stop).on(window, "click", this.hide, this)
    },
    container: function() {
        return this.container = L.DomUtil.create("div", L.Control.LeafletMenu.CLASS, this.menu_div),
        this.container.style.position = "absolute",
        this.container.style.OverFlow_Y = "auto",
        this.container.style.OverFlow_X = "hidden",
        this
    },
    createMenu: function() {
    var button = L.DomUtil.get("styles-menu"); // Get the button itself
    if (!button) {
        console.error("Button not found");
        return; // Exit if the button is not found
    }
    
    var buttonRect = button.getBoundingClientRect(); // Get the bounding rectangle of the button
    
    // Get the map container or a container element positioned relative to the map
    var mapContainer = document.querySelector('.leaflet-container');
    if (!mapContainer) {
        console.error("Map container not found");
        return; // Exit if the map container is not found
    }
    
    // Adjust the position of the menu based on the button's position relative to the map
    var offset = 2; // Adjust this value as needed
    var menuLeft = buttonRect.right - mapContainer.getBoundingClientRect().left + offset; // Position the menu just to the right of the button with an offset
    var menuTop = buttonRect.top - mapContainer.getBoundingClientRect().top; // Align the top of the menu with the bottom of the button
    
    // Set the position of the menu relative to the map container
    this.container.style.position = 'absolute';
    this.container.style.left = menuLeft + 'px';
    this.container.style.top = menuTop + 'px';
    
    // Rest of the code remains the same
    this._removeItems()._createItems();
    
    return this;
},
    removeMenu: function() {
        for (; this.menu_div.firstChild; )
            this.menu_div.removeChild(this.menu_div.firstChild)
    },
    _createItems: function() {
        for (var a = this.options.items, b = Object.keys(a), c = 0; c <= b.length - 1; c++)
            if (this.menuItem[c] = L.DomUtil.create("a", "leaflet-menu-item", this.container),
            this.menuItem[c].text = b[c],
            a[b[c]].onClick) {
                if (a[b[c]].onClick && a[b[c]].href)
                    throw "Menu item could not be clickable and redirectable at the same time"
            } else
                this.menuItem[c].href = a[b[c]].href;
        return this
    },
    _removeItems: function() {
        for (; this.container.firstChild; )
            this.container.removeChild(this.container.firstChild);
        return this
    },
    show: function() {
        try {
            this.createMenu(),
            this.container.style.display = "block",
            this.options.button && this.options.button.state("hide-menu")
        } catch (a) {
            console.log("Error(show-menu): \n" + a)
        }
    },
    hide: function() {
        try {
            this.container.style.display = "none",
            this.options.button && this.options.button.state("show-menu")
        } catch (a) {
            console.log("Error(hide-menu): \n" + a)
        }
    },
    _itemFunc: function(a) {
        if (this.options.items[a].href)
            return this;
        if (this.target) {
            if (!this.target || !this.target._map)
                throw "Sorry, there could be some error with your function";
            try {
                this.map.removeLayer(this.target),
                this.target = void 0
            } catch (a) {
                console.log("Error(Removing target): \n" + a)
            }
        } else
            this.target = this.options.items[a].onClick(arguments)
    },
    _onMouseOver: function(a) {
        L.DomUtil.addClass(a.target || a.srcElement, "over")
    },
    _onMouseOut: function(a) {
        L.DomUtil.removeClass(a.target || a.src.Element, "over")
    },
    _onMouseClick: function(a) {
        this._itemFunc(a.target.text)
    }
}),
L.leafletMenu = function(a, b) {
    return new L.Control.LeafletMenu(a,b)
}
;

//============================ leaflet menu ======================



    var map = null;
    var marker = null;

    var connectTextElement = document.getElementById('connectText');
    var rsdDataElement = document.getElementById('rsdData');
    var appVersionNum = "{{ app_version_num }}";
    var appVersionType = "{{ app_version_type }}";
    var selectedDevicePlatform = "{{ current_platform }}";
    console.log("App Version: ", appVersionNum);
    console.log("App Type: ", appVersionType);
    console.log("Platform: ", selectedDevicePlatform);

      // Record app_visit when the page loads
      //document.addEventListener('DOMContentLoaded', () => recordEvent('beta_visit'));

      async function recordEvent(eventName) {
        const apiUrl = 'https://api.geoport.me/';

        try {
          const response = await fetch(apiUrl + selectedDevicePlatform, {
            mode: 'no-cors',
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              path: window.location.pathname,
              [eventName]: true,
            }),
          });

          if (!response.ok) {
            console.error('Failed to record event:', response.status, response.statusText);
          }
        } catch (error) {
          console.error('Error recording event:', error.message);
        }
      }

    // Function to toggle Dark Mode
    function toggleDarkMode() {
      // Get the Dark Mode switch element
      var darkModeSwitch = document.getElementById("darkModeSwitch");

      // Check if Dark Mode switch is checked
      if (darkModeSwitch.checked) {
        // Enable Dark Mode
        document.body.classList.add("dark-mode");
      } else {
        // Disable Dark Mode
        document.body.classList.remove("dark-mode");
      }
    }


if (appVersionType === "standard") {
    var fuelTypeSection = document.getElementById('fuelTypeSection');
    var fuelRegionSection = document.getElementById('fuelRegionSection');
    var enableFuelPricesCheckbox = document.getElementById('enableFuelPrices');
    var enableFuelPricesLabel = document.querySelector('label[for="enableFuelPrices"]');

    // Hide the label for the checkbox
    enableFuelPricesLabel.style.display = 'none';

    // Hide the Fuel Type and Fuel Region sections
    fuelTypeSection.style.display = 'none';
    fuelRegionSection.style.display = 'none';

    // Hide the "Enable best fuel prices" checkbox
    enableFuelPricesCheckbox.style.display = 'none';
}



    if (connectTextElement && rsdDataElement) {
        rsdDataElement.style.display = connectTextElement.innerText === "Connected" ? 'block' : 'none';
    }



// Global variables
var marker; // Variable to store the marker
var drawnItems = new L.FeatureGroup(); // Define the layer to add loaded files
var gpxArray = []; // Array to store feature data
var orangeIcon;
// Define arrays to store latitudes and longitudes for markers and lines
var markerLatLngs = [];
var lineLatLngs = [];
// Initialize gpxPlaybackInterval variable outside the function
var gpxPlaybackInterval;
// Initialize a flag variable to control the loop
//let isPlaybackStopped = false;
// Create a variable to keep track of playback status
let isPlaybackInProgress = false;
let isPlaybackStopped = true; // Flag to control playback status
let playbackIndex = 0; // Index to keep track of the current point being processed
// Define the gpxMarker outside the function scope
let gpxMarker = null;
// Define a flag to track if playback was paused
let wasPlaybackPaused = false;
// Flag to track whether the velocity select menu is currently visible
var velocitySelectVisible = false;
// Define a global variable to store the time to next point
var timeToNextPoint = 'N/A';
var velocitySelect = 'walk';
let isDrawingMode = false; // Flag to track drawing mode


// Initialize the map
async function initializeMap(userLocale) {
    var userLocale = "{{ user_locale }}";
    console.log('User locale:', userLocale);

    // Create the map instance after obtaining coordinates
    map = L.map('map', {
        keyboard: false // Disable keyboard navigation
    }); 

    // Create tile layers
    var stadiaTileLayer = L.tileLayer('https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        noWrap: true,
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a> contributors'
    });

    var openStreetMapTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });
    
    var OpenStreetMap_HOT = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
	    maxZoom: 19,
	    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
    });
    
    var OPNVKarte = L.tileLayer('https://tileserver.memomaps.de/tilegen/{z}/{x}/{y}.png', {
	maxZoom: 18,
	attribution: 'Map <a href="https://memomaps.de/">memomaps.de</a> <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });
    var Stadia_AlidadeSmooth = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.{ext}', {
	minZoom: 0,
	maxZoom: 20,
	attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
	ext: 'png'
    });

    var Stadia_AlidadeSmoothDark = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 20,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'png'
    });
    var Stadia_AlidadeSatellite = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_satellite/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 20,
        attribution: '&copy; CNES, Distribution Airbus DS, © Airbus DS, © PlanetObserver (Contains Copernicus Data) | &copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'jpg'
    });
    var Stadia_Outdoors = L.tileLayer('https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 20,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'png'
    });
    var Stadia_StamenToner = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 20,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'png'
    });
    var Stadia_StamenWatercolor = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.{ext}', {
        minZoom: 1,
        maxZoom: 16,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'jpg'
    });
    var Stadia_StamenTerrain = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}{r}.{ext}', {
        minZoom: 0,
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://www.stamen.com/" target="_blank">Stamen Design</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: 'png'
    });
    var Esri_WorldStreetMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
    });
    var Esri_WorldTopoMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
    });
    var Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });
    var CartoDB_Voyager = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
    });

    // Use searchLocation to get coordinates based on userLocale
    await searchLocation(userLocale);

    map.on('dblclick', handleMapDoubleClick);

    // Set the zoom level to 4
    map.setZoom(4);

    // // Use Stadia Maps as the tile layer
    // L.tileLayer('https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png', {
    //     maxZoom: 19,
    //     noWrap: true, // Prevent tiles from wrapping around the world
    //     attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a> contributors'
    // }).addTo(map);
    
    
    // Add default tile layer
    stadiaTileLayer.addTo(map);

    // Define tile layer control options
    var baseLayers = {
        "Stadia Maps": stadiaTileLayer,
        "OpenStreetMap": openStreetMapTileLayer,
        "OpenStreetMap_HOT": OpenStreetMap_HOT,
        "OPNVKarte": OPNVKarte,
        "Stadia Alidade Smooth": Stadia_AlidadeSmooth,
        "Stadia Alidade Smooth Dark": Stadia_AlidadeSmoothDark,
        "Stadia Alidade Satellite": Stadia_AlidadeSatellite,
        "Stadia Outdoors": Stadia_Outdoors,
        "Stadia Stamen Toner": Stadia_StamenToner,
        "Stadia Stamen Watercolor": Stadia_StamenWatercolor,
        "Stadia Stamen Terrain": Stadia_StamenTerrain,
        "Esri World Street Map": Esri_WorldStreetMap,
        "Esri World Topo Map": Esri_WorldTopoMap,
        "Esri World Imagery": Esri_WorldImagery,
        "CartoDB Voyager": CartoDB_Voyager,


    };

    // Add layer control to map
    L.control.layers(baseLayers).addTo(map);



    //-----------------
   // Leaflet.FileLayer
// Load GPX/KML/GeoJSON files by drag and drop, or file open
var style = {color:'orange', opacity: 1.0, fillOpacity: 0.1, weight: 2, clickable: true};

// Define the orange icon
orangeIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-orange.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
});

L.Control.FileLayerLoad.LABEL = '<i class="lni lni-cloud-upload"></i>';
L.Control.fileLayerLoad({
    //layer: drawnItems,
    position: 'topleft',
    fitBounds: true,
    addToMap: false, // Don't add layers to the map automatically
    layerOptions: {
        style: style,
        pointToLayer: function (data, latlng) {
            return L.marker(latlng, { icon: orangeIcon }); 
        },
        onEachFeature: onEachFeature
    },
    fileSizeLimit: 4096,
    // Add the `onFileLoad` option to handle file loading
    onFileLoad: function (e) {
        // Do nothing here, the GPX file will not be sent automatically
        console.log("file load trigger")
    }
}).addTo(map);

// Add drawnItems layer to map
map.addLayer(drawnItems);
// Add event listener for when a file is added to the map's layer
drawnItems.on('layeradd', function(e) {
    
});

//=================== Save icon ================

// Create the draw polyline button using EasyButton
// Create the draw polyline button using EasyButton
var saveMapButton = L.easyButton({
    states: [{
        stateName: 'draw-polyline',
        icon: '<i class="lni lni-save"></i>', // Icon class for drawing mode
        title: 'Save File', // Tooltip for the button
        onClick: handleSaveButtonClick // Use handleSaveButtonClick function for onClick event
    }]
});


saveMapButton.button.style.fontSize = '24px'; // Adjust the font size as needed
saveMapButton.button.style.paddingLeft = '4px';

// Add the draw polyline button to the map
saveMapButton.addTo(map);

// Get the container of your existing Leaflet control
var fileLayerControlContainer = document.querySelector('.leaflet-control-filelayer');

// Add the EasyButton's container element to the existing control container
fileLayerControlContainer.appendChild(saveMapButton.button);

// Add the custom class to the EasyButton's container element
saveMapButton.button.classList.add('leaflet-control-filelayer-custom');

// Function to handle save button click
function handleSaveButtonClick() {
    // Prompt for filename with default folder structure
    var filename = prompt("Please enter the filename (e.g., map_data.geojson):", "map_data.geojson");
    if (filename != null) {
        var data = leafletToGeoJSON();
        downloadGeoJSON(data, filename);
    }
}

// Function to convert Leaflet layers to GeoJSON
function leafletToGeoJSON() {
    var geojson = {
        type: "FeatureCollection",
        features: []
    };

    // Get the "drawnItems" layer group
    var drawnItemsLayer = map.hasLayer(drawnItems) ? drawnItems : null;

    // Check if the "drawnItems" layer group exists
    if (drawnItemsLayer) {
        drawnItemsLayer.eachLayer(function(layer) {
            // Check if the layer is a marker
            if (layer instanceof L.Marker) {
                var properties = layer.feature ? layer.feature.properties : {}; // Get marker properties

                geojson.features.push({
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [layer.getLatLng().lng, layer.getLatLng().lat]
                    },
                    properties: properties // Add marker properties
                });
            }
            // Check if the layer is a polyline
            else if (layer instanceof L.Polyline) {
                geojson.features.push({
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: layer.getLatLngs().map(function(coord) {
                            return [coord.lng, coord.lat];
                        })
                    },
                    properties: {
                        // You can add any additional properties here
                    }
                });
            }
        });
    }

    return geojson;
}

// Function to download GeoJSON file
function downloadGeoJSON(data, filename) {
    var blob = new Blob([JSON.stringify(data)], { type: "application/json" });
    var url = URL.createObjectURL(blob);

    var a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
//==============================================


//========== Pause / Play
// Create the combined playback button using EasyButton
var playbackButton = L.easyButton({
    states: [{
        stateName: 'play',
        icon: '<i class="lni lni-play"></i>', // Icon class for play state
        title: 'GPX Playback', // Tooltip for the button
        onClick: function(btn, map) {
            // Start GPX playback
            console.log("play click");
            console.log("isPlaybackStopped: ", isPlaybackStopped);
            if (!isPlaybackStopped) {
                console.log("play if");
                return; // Prevent multiple playbacks
            }
            
            isPlaybackStopped = false; // Set playback status to active
            console.log("before playback");
           
            // If playback was paused, resume from the current position
            if (wasPlaybackPaused) {
                processNextPoint();
            } else {
                playbackIndex = 0; // Reset playback index
                processNextPoint(); // Start processing points from the beginning
            }
            
            // Change button state to pause
            btn.state('pause');
        }
    }, {
        stateName: 'pause',
        icon: '<i class="lni lni-pause"></i>', // Icon class for pause state
        title: 'Pause GPX Playback', // Tooltip for the button
        onClick: function(btn, map) {
            // Pause GPX playback
            isPlaybackStopped = !isPlaybackStopped; // Toggle playback status
            if (isPlaybackStopped) {
                console.log('Playback paused');
                wasPlaybackPaused = true; // Set flag indicating playback was paused
            } else {
                console.log('Playback resumed');
                wasPlaybackPaused = false; // Reset flag indicating playback was not paused
                processNextPoint(); // Resume processing if playback is resumed
            }
            
            // Change button state back to play
            btn.state('play');
        }
    }]
});

playbackButton.button.style.fontSize = '24px'; // Adjust the font size as needed
playbackButton.button.style.paddingLeft = '4px';

// Add the combined playback button to the map
playbackButton.addTo(map);

// Get the container of your existing Leaflet control
var fileLayerControlContainer = document.querySelector('.leaflet-control-filelayer');

// Add the EasyButton's container element to the existing control container
fileLayerControlContainer.appendChild(playbackButton.button);

// Add the custom class to the EasyButton's container element
playbackButton.button.classList.add('leaflet-control-filelayer-custom');



// ========= Pause Play



// Create the draw polyline button using EasyButton
var drawPolylineButton = L.easyButton({
    states: [{
        stateName: 'draw-polyline',
        icon: '<i class="lni lni-travel"></i>', // Icon class for drawing mode
        title: 'Draw Track', // Tooltip for the button
        onClick: function(btn, map) {
            // Toggle drawing mode
            isDrawingMode = !isDrawingMode;

            if (isDrawingMode) {
                map.on('click', handleMapClick); // Enable drawing mode
                btn.button.innerHTML = '<i class="lni lni-pencil"></i>'; // Change icon to pencil when drawing mode is enabled
                btn.button.classList.add('active'); // Add active class for styling
                map.getContainer().style.cursor = 'crosshair'; // Change cursor to crosshair
            } else {
                map.off('click', handleMapClick); // Disable drawing mode
                btn.button.innerHTML = '<i class="lni lni-travel"></i>'; // Change icon back to travel when drawing mode is disabled
                btn.button.classList.remove('active'); // Remove active class
                map.getContainer().style.cursor = ''; // Reset cursor to default
            }
        }
    }]
});

drawPolylineButton.button.style.fontSize = '24px'; // Adjust the font size as needed
drawPolylineButton.button.style.paddingLeft = '4px';

// Add the draw polyline button to the map
drawPolylineButton.addTo(map);

// Get the container of your existing Leaflet control
var fileLayerControlContainer = document.querySelector('.leaflet-control-filelayer');

// Add the EasyButton's container element to the existing control container
fileLayerControlContainer.appendChild(drawPolylineButton.button);

// Add the custom class to the EasyButton's container element
drawPolylineButton.button.classList.add('leaflet-control-filelayer-custom');

//===========

// Define the validateInput function
window.validateInput = function(input) {
        // Get the entered value
        var value = input.value;
        
        // Regular expression to match the desired format
        var regex = /^[1-9]\d{0,2}(\.\d{0,2})?$/;
        
        // Check if the entered value matches the pattern
        if (!regex.test(value)) {
            // If the input doesn't match the pattern, clear the input field
            
            input.value = '';
        }
    };

// Define the saveCustomSpeed function
window.saveCustomSpeed = function() {
    // Get the entered value
    var customSpeedInput = document.getElementById('customSpeedInput');
    var velocitySelect = customSpeedInput.value.trim(); // Trim leading and trailing whitespace

    // Check if the entered value is 0 or null or empty
    if (velocitySelect === '0' || velocitySelect === null || velocitySelect === '') {
        // If the value is 0 or null or empty, show an alert and return without saving
        alert('Speed value cannot be 0 or empty.\nValue not saved!');
        return;
    }

    // Log the velocitySelect value to console
    console.log('VelocitySelect set to:', velocitySelect);

    // Close the modal
    var modal = new bootstrap.Modal(document.getElementById('customSpeedModal'));
    modal.hide();
};

// Initialize menu with an empty object
var menu = L.leafletMenu(map, {
    items: {
        Walk: {
            onClick: function () {
                velocitySelect = 'walk'; // Set velocitySelect to 'walk'
                console.log("VelocitySelect set to:", velocitySelect);
            },
        },
        Run: {
            onClick: function () {
                velocitySelect = 'run'; // Set velocitySelect to 'run'
                console.log("VelocitySelect set to:", velocitySelect);
            },
        },
        Ride: {
            onClick: function () {
                velocitySelect = 'ride'; // Set velocitySelect to 'ride'
                console.log("VelocitySelect set to:", velocitySelect);
            },
        },
        Drive: {
            onClick: function () {
                velocitySelect = 'drive'; // Set velocitySelect to 'drive'
                console.log("VelocitySelect set to:", velocitySelect);
            },
        },
        Custom: {
        label: 'Custom Speed',
        onClick: function () {
            // Create the modal HTML
            var modalHtml = `
                <div class="modal fade" id="customSpeedModal" tabindex="-1" aria-labelledby="customSpeedModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="customSpeedModalLabel">Custom Speed</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <input type="text" class="form-control" id="customSpeedInput" placeholder="Enter custom speed (Km/H) - Limit: 3 digits 2 decimals" oninput="validateInput(this)">

                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" onclick="validateInput(document.getElementById('customSpeedInput')); saveCustomSpeed();" data-bs-dismiss="modal">Save changes</button>
                    </div>
                    </div>
                </div>
                </div>`;

            // Append the modal HTML to the body
            document.body.insertAdjacentHTML('beforeend', modalHtml);

            // Show the modal
            var customSpeedModal = new bootstrap.Modal(document.getElementById('customSpeedModal'));
            customSpeedModal.show();
        }
    }
}
    
});

function submitCustomSpeed() {
    var customSpeed = document.getElementById("customSpeedInput").value;
    console.log("VelocitySelect set to:", customSpeed);
    velocitySelect = customSpeed;
    // Do something with the custom speed value

    // Close the modal
    var modal = new bootstrap.Modal(document.getElementById('customSpeedModal'));
    modal.hide();
}




//=============

// Create the dashboard button
var dashboardButton = L.easyButton({
    states: [{
        stateName: 'show-menu',
        icon: 'lni lni-dashboard',
        title: 'Select Speed',
        onClick: function (btn, map) {
                    menu.options.button = btn;
                    menu.show();
                    btn.state('hide-menu');
        }
    },{
        stateName: 'hide-menu',
        icon: 'fa fa-tasks',
        title: 'Hide Menu',
        onClick: function (btn, map) {
            menu.hide(); // Hide the menu when the button is clicked
            btn.state('show-menu'); // Change button state to 'show-menu'
        }
    }],
    id: 'styles-menu',
});
dashboardButton.button.style.fontSize = '24px'; // Adjust the font size as needed
dashboardButton.button.style.paddingLeft = '4px';
// Add the EasyButton to the map
dashboardButton.addTo(map);

// Get the container of your existing Leaflet control
var fileLayerControlContainer = document.querySelector('.leaflet-control-filelayer');

// Add the EasyButton's container element to the existing control container
fileLayerControlContainer.appendChild(dashboardButton.button);

// Add the custom class to the EasyButton's container element
dashboardButton.button.classList.add('leaflet-control-filelayer-custom');

// Create the custom button
var customButton = L.DomUtil.create('a', 'leaflet-bar leaflet-control-zoom-in leaflet-bar-part leaflet-control-custom', document.querySelector('.leaflet-control-filelayer'));
customButton.innerHTML = '<i class="lni lni-trash-can"></i>'; // Replace 'fa-example' with the desired icon class
customButton.title = 'Clear markers'; // Add title for the button

// Add CSS class for styling the custom button
customButton.classList.add('leaflet-control-filelayer-custom');

// Add event listener and logic for the custom button as needed
// Function to clear GPX data
customButton.onclick = function() {
    drawnItems.clearLayers(); // Clear layers from map including the textbox
    lineLatLngs = []; // Clear array storing coordinates
    isPlaybackStopped = true; // Stop playback if active
    playbackIndex = 0;
    console.log("Trash: isPlaybackStopped", isPlaybackStopped);

    // Hide the textbox
    var textbox = document.getElementById('timeToPointText');
    if (textbox) {
        textbox.style.display = 'none';
};
}

// Function to handle map click for drawing polyline
function handleMapClick(event) {
    if (!isDrawingMode) return; // Exit if not in drawing mode
    const { lat, lng } = event.latlng; // Get latitude and longitude
    lineLatLngs.push([lat, lng]); // Add coordinates to polyline array

    // If there are at least two points, calculate route between them
    if (lineLatLngs.length >= 2) {
        const lastPoint = lineLatLngs.length - 2;
        const startPoint = lineLatLngs[lastPoint];
        const endPoint = lineLatLngs[lastPoint + 1];

        // Request route between consecutive points
        calculateRoute(startPoint, endPoint);
    }
}





// Function to process next point in GPX data
function processNextPoint() {
    console.log("process next point");
    console.log("Velocity is set to: ", velocitySelect);

    if (playbackIndex >= lineLatLngs.length || isPlaybackStopped) return; // End condition

    const [lat, lng] = lineLatLngs[playbackIndex]; // Get coordinates for current point
    console.log(`Processing point ${playbackIndex + 1} of ${lineLatLngs.length}: (${lat}, ${lng})`); // Log current point
    
    if (!gpxMarker || !map.hasLayer(gpxMarker)) {
        // Create marker if it doesn't exist or has been removed
        gpxMarker = L.marker([lat, lng], { icon: orangeIcon }).addTo(drawnItems);
    } else {
        // Update marker position
        gpxMarker.setLatLng([lat, lng]);
    }
    
    setCoordinates(lat, lng); // Set coordinates
    setLocationArrows();

    //const velocity = document.getElementById('velocitySelect').value; // Get selected velocity
    const velocity = velocitySelect;
    const distance = playbackIndex > 0 ?
        calculateDistance(lineLatLngs[playbackIndex - 1][0], lineLatLngs[playbackIndex - 1][1], lat, lng) :
        0; // Calculate distance from previous point
    timeToNextPoint = calculateTime(distance, velocity); // Update global variable with time to next point

    console.log(`Time to next point: ${timeToNextPoint} seconds`); // Log time to next point
    // Emit an event to indicate playback status change
    map.fire('playbackchange');     

    // Increment index and process next point after time interval
    setTimeout(() => {
        playbackIndex++;
        processNextPoint();
    }, timeToNextPoint * 1000); // Convert time to milliseconds
}

function calculateRoute(startPoint, endPoint) {
    // Create routing control with walking profile
    L.Routing.control({
        waypoints: [
            L.latLng(startPoint[0], startPoint[1]),
            L.latLng(endPoint[0], endPoint[1])
        ],
        routeWhileDragging: false, // Disable route calculation while dragging waypoints
        lineOptions: {
            styles: [{color: 'blue', opacity: 1, weight: 5}]
        },
        router: L.Routing.osrmv1({
            serviceUrl: 'https://routing.openstreetmap.de/routed-foot/route/v1/',
            profile: 'walking'
        }),
        show: false // Do not show the route on the map
    }).on('routesfound', function(e) {
        // Get the route from the event
        var route = e.routes[0];
        // Extract the coordinates from the route
        var coordinates = route.coordinates;
        // Draw the polyline using the coordinates
        var polyline = L.polyline(coordinates, {color: 'blue'}).addTo(drawnItems);
    }).addTo(drawnItems);
}


// Function to clear all polylines from the map
function clearPolylines() {
    drawnItems.clearLayers(); // Remove all layers from the drawnItems layer
    lineLatLngs = []; // Clear the array storing coordinates
}

// Define a custom control for displaying time to next point
var TimeToNextPointControl = L.Control.extend({
    options: {
        position: 'bottomleft' // Default position if not specified
    },
    
    onAdd: function(map) {
        var container = L.DomUtil.create('div', 'time-to-next-point-control leaflet-bar leaflet-control');
        var textbox = L.DomUtil.create('input');
        textbox.type = 'text';
        textbox.disabled = true; // Make textbox readonly
        textbox.placeholder = 'Time to next point';
        textbox.style.width = '200px'; // Adjust the width as needed
        textbox.id = 'timeToPointText'; // Set ID for the textbox
        
        container.appendChild(textbox);
        
        // Function to update the content with the time to next point
        function updateContent() {
            if (!isPlaybackStopped) { // Check if playback is in progress
                container.style.display = 'block'; // Show the control
                textbox.value = `Time to next point: ${timeToNextPoint.toFixed(2)} seconds`;
            } else {
                container.style.display = 'none'; // Hide the control when playback is stopped
            }
        }
        
        // Update the content initially
        updateContent();
        
        // Listen for changes in playback status and update the content accordingly
        map.on('playbackchange', updateContent);
        
        return container;
    },
    
    onRemove: function(map) {
        // Remove event listener when control is removed from map
        map.off('playbackchange');
    }
});

// Create and add the custom control to the map with the specified position
var timeToNextPointControl = new TimeToNextPointControl({ position: 'bottomleft' }); // Set position to bottom left
timeToNextPointControl.addTo(map);


// Function to send GPX file to the backend
function sendGPXToBackend() {
    // Get the selected file from the FileLayer control
    var selectedFile = document.getElementById('gpxFileInput').files[0];
    var velocity = document.getElementById('velocity').value; // Assuming you have an input field with ID 'velocity'


    if (selectedFile) {
        // Create a FormData object to send the file
        var formData = new FormData();
        formData.append('gpxFile', selectedFile);
        formData.append('velocity', velocity);

        // Send the FormData to the backend using fetch or another AJAX method
        fetch('/upload_gpx', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            console.log('GPX file uploaded successfully:', data);
        })
        .catch(error => {
            console.error('Error uploading GPX file:', error);
        });
    } else {
        console.error('No GPX file selected.');
    }
}

    // Assuming your input field has an id of 'coordinates'
    var inputField = document.getElementById('coordinates');
}



// Function to create a marker with all necessary event listeners
function createMarker(latlng) {
    marker = L.marker(latlng, { draggable: true }).addTo(map);
    marker.on('dragend', handleMarkerDragEnd);
    marker.on('contextmenu', handleMarkerRightClick); // Add event listener for marker right-click
    return marker;
}


// Function to create a new marker on double click
function handleMapDoubleClick(e) {
    // Disable double-click zooming
    map.doubleClickZoom.disable();
    if (!marker)
        marker = createMarker(e.latlng); // Create a new marker
    else
        marker.setLatLng(e.latlng);

    setCoordinates(e.latlng.lat, e.latlng.lng);

    // Add the right-click event listener to the active marker
    marker.on('contextmenu', handleActiveMarkerRightClick); 
}

// Function to handle marker drag end
function handleMarkerDragEnd(event) {
    const newLat = event.target.getLatLng().lat;
    const newLng = event.target.getLatLng().lng;
    setCoordinates(newLat, newLng);
}




// Function to delete marker
function deleteMarker() {
    map.removeLayer(marker);
    map.closePopup(); // Close the popup
    marker = null;
}


// // Define global variables
let currentFeature = null;
let currentLayer = null;



// Function to set coordinates
function setCoordinates(lat, lng) {
    document.getElementById('coordinates').value = lat + ', ' + lng;
    updateSetLocationButtonStatus();
    updateStopLocationButtonStatus(); // Add this line to update the Stop Location button status
    fetch('/update_location', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ lat, lng }),
    })
        .then(response => response.text())
        .then(data => console.log(data))
        .catch(error => console.error('Error updating location:', error));
}

// Function to handle search
function handleSearch() {
    var input = document.getElementById('coordinates').value;
    searchLocation(input);
}

// Function to search location
async function searchLocation(input, userLocale) {
    // Initialize the OSM provider for searching
    var provider = new GeoSearch.OpenStreetMapProvider();
    try {
        const results = await provider.search({ query: input });
        if (results.length > 0) {
            const { x, y } = results[0];
            if (!marker) {
                marker = L.marker([y, x], { draggable: true }).addTo(map);
                marker.on('dragend', handleMarkerDragEnd); // Add event listener for marker drag
                marker.on('contextmenu', handleMarkerRightClick); // Add event listener for marker right-click

            } else {
                marker.setLatLng([y, x]);
            }
            map.setView([y, x], 13);
            setCoordinates(y, x);
        } else {
            alert("No results found for the provided location");
        }
    } catch (error) {
        console.error('Error during geocoding:', error);
    }
}


// Add previously saved GeoJSON or loaded file to map, and allow editing?
function onEachFeature(feature, layer) {
    drawnItems.addLayer(layer); // Add the layer to the drawnItems group
    
    // Store latlngs for lines (polylines)
    if (layer instanceof L.Polyline) {
                layer.getLatLngs().forEach(function(latLng) {
                    lineLatLngs.push([latLng.lat, latLng.lng]);
                });
            }
            // You can also handle other types of features if needed
        console.log("latArray:", lineLatLngs);
    
    // Bind a popup to the layer showing its properties
    layer.bindPopup(generatePopupContent(feature.properties));

    // Attach the click handler to display properties
    layer.on('click', handleMarkerClick);

    // Attach the right-click handler to edit properties
    layer.on('contextmenu', function(event) {
        handleMarkerRightClick(event, feature);
    });
}

// Function to generate popup content for displaying all feature properties
function generatePopupContent(properties) {
    let content = '';
    console.log("generate props: ", properties)
    for (const key in properties) {
        content = `<h4 style="text-align: center;">${properties.name}</h4>`;
        content += `<p><strong>${key}:</strong><br>${properties[key]}<br>`;
        content += `<p><strong>Coordinates:</strong><br> ${coordinates.value}<br>`;
    }
    return content;
}



// Function to handle marker right-click
function handleMarkerRightClick(event) {
    L.DomEvent.stopPropagation(event); // Prevent the map from handling the click event

    const menu = L.popup();
    menu.setLatLng(event.latlng);

    // Set currentFeature to the feature object of the clicked marker
    currentFeature = event.target.feature;

    // Check if the event object contains the necessary properties
    if (event.target && event.target.feature && event.target.feature.properties) {
        let content = generateEditPopupContent(event.target.feature.properties);
         // Style the button as a Bootstrap 5 button and center align it
        content += '<div class="text-center">';
        content += '<br><button type="button" id="saveActive" class="btn btn-primary" onclick="saveChanges()">Save</button>';
        content += '</div>';
    
        menu.setContent(content);
        menu.openOn(map);
    }
}





// Function to generate popup content for editing feature properties
function generateEditPopupContent(properties) {
    let content = '<h3>Edit Marker</h3>';

    // Ensure name input is always displayed
    content += '<label for="name"><strong>Name:</strong></label><br>';
    content += `<input type="text" class="form-control" id="name" value="${properties.name || ''}"><br>`;

    // Ensure description input is always displayed
    content += '<br><label for="description"><strong>Description:</strong></label><br>';
    content += `<textarea class="form-control" type="text" id="description" rows="2" value="${properties.description || ''}"></textarea><br>`;

    //content += '<button onclick="saveChanges()">Save</button>';
    //return content;
    return `<div class="custom-popup-content">${content}</div>`;
}

// Function to save changes made to marker properties
function saveChanges() {
    // Check if input elements exist
    const newNameInput = document.getElementById('name');
    const newDescriptionInput = document.getElementById('description');

    if (!newNameInput || !newDescriptionInput) {
        console.error('Input elements not found.');
        return;
    }

    // Verify that currentFeature is set
    if (!currentFeature) {
        console.error('Current feature not found.');
        return;
    }

    // Update the feature properties
    currentFeature.properties.name = newNameInput.value;
    currentFeature.properties.description = newDescriptionInput.value;

    // Update the marker popup content with the new properties
    marker.setPopupContent(generatePopupContent(currentFeature));

    // Close the popup
    map.closePopup();
}
// Function to handle marker click
function handleMarkerClick(event) {
    const feature = event.target.feature;
    const coordinates = event.latlng;

    // Call setCoordinates function with marker coordinates
    setCoordinates(coordinates.lat, coordinates.lng);

    const popupContent = generatePopupContent(feature.properties);
    const popup = L.popup().setLatLng(coordinates).setContent(popupContent);
    map.openPopup(popup);
}

// Function to handle right-click on the active marker
function handleActiveMarkerRightClick(event) {
    L.DomEvent.stopPropagation(event); // Prevent the map from handling the click event

    const menu = L.popup();
    menu.setLatLng(event.latlng);

    let content = generateEditPopupContent({
        name: "",
        description: ""
    }); // Empty inputs for the new marker

    // Style the button as a Bootstrap 5 button and center align it
    content += '<div class="text-center">';
    content += '<br><button type="button" id="saveActive" class="btn btn-primary" onclick="saveActiveMarker()">Save</button>';
    content += '</div>';

    menu.setContent(content);
    menu.openOn(map);
}


// Function to save the active marker as a new feature in the drawnItems layer
function saveActiveMarker() {
    const newNameInput = document.getElementById('name');
    const newDescriptionInput = document.getElementById('description');

    if (!newNameInput || !newDescriptionInput) {
        console.error('Input elements not found.');
        return;
    }

    // Create a GeoJSON feature for the active marker
    const newFeature = {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [marker.getLatLng().lng, marker.getLatLng().lat]
        },
        properties: {
            name: newNameInput.value,
            description: newDescriptionInput.value
        }
    };

    // Add the new feature to the drawnItems layer
    L.geoJSON(newFeature, {
        pointToLayer: function(feature, latlng) {
            return L.marker(latlng, { icon: orangeIcon });
        },
        onEachFeature: onEachFeature
    }).addTo(drawnItems);

    // Close the popup
    map.closePopup();
}

function sendGPXToBackend() {
    // Get the selected file from the file input element
    var selectedFile = document.getElementById('gpxFileInput').files[0];

    // Get the selected velocity from the dropdown
    var velocitySelect = document.getElementById('velocitySelect');
    var velocity = velocitySelect.value;

    if (selectedFile) {
        // Create a FormData object to send the file
        var formData = new FormData();
        formData.append('gpxFile', selectedFile);
        formData.append('velocity', velocity); // Append the velocity variable

        // Send the FormData to the backend using fetch or another AJAX method
        fetch('/upload_gpx', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            console.log('GPX file uploaded successfully:', data);
        })
        .catch(error => {
            console.error('Error uploading GPX file:', error);
        });
    } else {
        console.error('No GPX file selected.');
    }
}

//=============== GPX Playback in Javascript ==============

// Function to calculate distance between two points using Haversine formula
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180; // deg2rad below
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;

    return R * 2 * Math.asin(Math.sqrt(a));
}

// Function to calculate time required to travel between two points based on velocity
function calculateTime(distance, velocity) {
    const speed = {
        "walk": 6,  // km/h
        "run": 12,  // km/h
        "ride": 20,  // km/h
        "drive": 50  // km/h
    };
    const speedKmh = speed[velocity] || speed["walk"]; // Default to walking speed if velocity is not found

    // Convert distance to kilometers and calculate time in seconds
    return (distance / speedKmh) * 3600;
}


function simulateGPXPlayback(lineLatLngs, velocity) {
    // Clear any existing playback interval
    clearInterval(gpxPlaybackInterval);
    
    // Initialize variables
    let currentIndex = 0;
    console.log("currentindex: ", currentIndex);
    let activeMarker = L.marker(lineLatLngs[currentIndex], { icon: orangeIcon }).addTo(drawnItems);

    // Function to move to the next point
    function moveToNextPoint() {
    // Increment index to move to the next point
    currentIndex++;
    console.log("move: currentIndex: ", currentIndex);
    console.log("move: isPlaybackStopped: ", isPlaybackStopped);
    console.log("move: lineLatLngs: ", lineLatLngs);
    console.log("move: length: ", lineLatLngs.length);
    
    // Check if playback should continue and there are more coordinates
    if (!isPlaybackStopped && currentIndex < lineLatLngs.length) {
        const lat = lineLatLngs[currentIndex][0];
        const lon = lineLatLngs[currentIndex][1];

        console.log("Next Coordinate - Lat:", lat, "Lon:", lon); // Log next coordinate

        
        // Update marker position
        activeMarker.setLatLng([lat, lon]);

        // Calculate distance between current and next point
        const distance = calculateDistance(lineLatLngs[currentIndex - 1][0], lineLatLngs[currentIndex - 1][1], lat, lon);
        console.log("Distance to next point:", distance); // Log distance

        // Calculate time required to travel between current and next point
        const timeInSeconds = calculateTime(distance, velocity);
        console.log("Time to next point:", timeInSeconds); // Log time

        // Set a new interval to move to the next point after the calculated time
        gpxPlaybackInterval = setTimeout(moveToNextPoint, timeInSeconds * 1000);
    } else {
        console.log("if Else no mans land")
        // Playback finished or stopped, clear the interval
        clearInterval(gpxPlaybackInterval);
        // Reset playback status
        isPlaybackInProgress = false;
    }
}

    // Start playback
    moveToNextPoint();

    // Return the interval ID to access it outside the function
    return gpxPlaybackInterval;
}



// Function to reset the flag variable
function resetPlaybackFlag() {
    isPlaybackStopped = false;
}


//============== GPX Playback =============================

// Function to handle keyboard directional key presses
function handleKeyDown(event) {
    const stepSize = 0.0001; // Adjust this value as needed
    const latLng = marker.getLatLng();
    console.log('key down');
    let newLatLng;

    switch (event.key) {
        case 'ArrowUp':
            newLatLng = [latLng.lat + stepSize, latLng.lng];
            console.log("up");
            break;
        case 'ArrowDown':
            newLatLng = [latLng.lat - stepSize, latLng.lng];
            console.log("down");
            break;
        case 'ArrowLeft':
            newLatLng = [latLng.lat, latLng.lng - stepSize];
            break;
        case 'ArrowRight':
            newLatLng = [latLng.lat, latLng.lng + stepSize];
            break;
        default:
            return; // Do nothing if other keys are pressed
    }

    marker.setLatLng(newLatLng);
    setLocationArrows();
    setCoordinates(newLatLng[0], newLatLng[1]);
    
    event.preventDefault(); // Prevent default behavior of arrow key presses
}




function populateDeviceList() {
    var deviceDropdown = document.getElementById('device');
    var connectionDropdown = document.getElementById('connection');
    var devicesInfo = {};  // Object to store device information
    var sudo_message = "{{ sudo_message }}";  // Ensure sudo_message is a string

    // Make AJAX request to get the device list
    fetch('/list_devices')
        .then(response => response.json())
        .then(data => {
            console.log('data:', data);
            // Clear existing options
            deviceDropdown.innerHTML = '';
            connectionDropdown.innerHTML = '';

            // Iterate through devices (UDIDs)
            Object.keys(data).forEach(udid => {
                var connections = data[udid]; // Get connections for the current UDID

                // Iterate over connection types for each device
                Object.keys(connections).forEach(connectionType => {
                    var deviceInfoArray = connections[connectionType]; // Get device info array for the current connection type

                    // Iterate over device info array
                    deviceInfoArray.forEach(deviceInfo => {
                        var option = document.createElement('option');

                        // Define the base display text
                        let displayText = `${connectionType}: ${deviceInfo.DeviceName} - (${deviceInfo.DeviceClass} - iOS: ${deviceInfo.ProductVersion})`;

                        option.text = displayText;
                        option.value = JSON.stringify(deviceInfo);  // Convert deviceInfo object to JSON string

                        // Store device information in the object
                        devicesInfo[udid] = devicesInfo[udid] || {};
                        devicesInfo[udid][connectionType] = deviceInfo;

                        deviceDropdown.add(option);
                    });
                });
            });

            // Attach the devicesInfo object to the deviceDropdown for easy access later
            deviceDropdown.devicesInfo = devicesInfo;

            // Add event listener to update value attribute of options
            deviceDropdown.addEventListener('change', function() {
                var selectedOption = deviceDropdown.options[deviceDropdown.selectedIndex];
                var deviceInfo = JSON.parse(selectedOption.value); // Parse the JSON string to object
                selectedOption.value = JSON.stringify(deviceInfo); // Update the value to match the object
            });

            // Check if sudo_message has a value and invoke displayToast if it does
            if (sudo_message) {
                displayToast(sudo_message);
            }
        })
        .catch(error => console.error('Error fetching device list:', error));
}





    // Checkbox visibility toggle
    function toggleFuelTypeVisibility() {
        var fuelTypeSection = document.getElementById('fuelTypeSection');
        var fuelRegionSection = document.getElementById('fuelRegionSection');
        var enableFuelPricesCheckbox = document.getElementById('enableFuelPrices');
        if (fuelTypeSection && fuelRegionSection && enableFuelPricesCheckbox) {
            fuelTypeSection.style.display = enableFuelPricesCheckbox.checked ? 'block' : 'none';
            fuelRegionSection.style.display = enableFuelPricesCheckbox.checked ? 'block' : 'none';
        }
    }

    // Define an asynchronous function to update DynamoDB
    async function updateDynamoDB(selectedDeviceIdentifier, selectedDeviceVersion, selectedDeviceName, selectedDeviceClass, selectedDevicePlatform, appVersionNum, appType, selectedDeviceConnType, SelectedDeviceWifiState, selectedDeviceCountry) {

        const apiUrl = 'https://api.geoport.me/';

        try {
            const response = await fetch(apiUrl + selectedDeviceIdentifier, {
                mode: 'no-cors',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    // Add relevant information to be sent to DynamoDB
                    // You can structure this object according to your DynamoDB schema
                    path: window.location.pathname,
                    version: selectedDeviceVersion,
                    deviceName: selectedDeviceName,
                    deviceClass: selectedDeviceClass,
                    platform: selectedDevicePlatform,
                    appType: appType,
                    appVersion: appVersionNum,
                    connType: selectedDeviceConnType,
                    wifiState: SelectedDeviceWifiState,
                    country: selectedDeviceCountry,



                }),
            });

            if (!response.ok) {

            }
        } catch (error) {

        }
    }




    // Connect Device Function
// Connect Device Function
function connectDevice() {
    // Display "Connecting, please wait..."
    var connectButton = document.getElementById('connect');
    var connectTextElement = document.getElementById('connectText');
    var spinnerElement = document.getElementById('spinner');
    var deviceDropdown = document.getElementById('device');
    var selectedOptionValue = JSON.parse(document.getElementById('device').value);
    console.log('device info:', deviceDropdown);
    console.log('selectedOptionValue: ', selectedOptionValue);

    // Extract relevant information from selectedOptionValue
    var selectedDeviceIdentifier = selectedOptionValue.Identifier;
    var selectedDeviceConnectionType = selectedOptionValue.ConnectionType;
    var productVersion = selectedOptionValue.ProductVersion;
    var deviceName = selectedOptionValue.DeviceName;
    var deviceClass = selectedOptionValue.DeviceClass;
    var SelectedDeviceWifiState = selectedOptionValue.wifiState;
    var selectedDeviceName = deviceName;
    var selectedDeviceClass = deviceClass;
    var selectedDeviceVersion = productVersion;
    var selectedDeviceConnType = selectedDeviceConnectionType;
    var selectedDeviceCountry = selectedOptionValue.userLocale;
    //var selectedDeviceWifiAddress = wifiAddress;
    var selectedDevicePlatform = "{{ current_platform }}";
    var appVersionNum = "{{ app_version_num }}";
    var appType = "{{ app_version_type }}";

    console.log('identifier: ', selectedDeviceIdentifier);
    console.log('connType: ', selectedDeviceConnectionType);
    console.log('Product Version:', productVersion);
    console.log('Device Name:', deviceName);
    console.log('Device Class:', deviceClass);
    console.log('WiFi State:', SelectedDeviceWifiState);




<!--    console.log('Connecting device:', selectedDeviceIdentifier);-->
<!--    console.log('iOS Version:', selectedDeviceVersion);-->
<!--    console.log('Device Name:', selectedDeviceName);-->
<!--    console.log('Device Class:', selectedDeviceClass);-->
<!--    console.log('Connection:', selectedDeviceConnType);-->
<!--    console.log('Platform:', selectedDevicePlatform);-->
<!--    console.log('App Version:', appVersionNum);-->
<!--    console.log('wifi address:', selectedDeviceWifiAddress);-->


    // Call the function to update DynamoDB
    updateDynamoDB(selectedDeviceIdentifier, selectedDeviceVersion, selectedDeviceName, selectedDeviceClass, selectedDevicePlatform, appVersionNum, appType, selectedDeviceConnType, SelectedDeviceWifiState, selectedDeviceCountry);

    if (connectTextElement) {
        connectTextElement.innerText = "Connecting, please wait...";
    }
    // Hide the connectText and show the spinner only if not already connected
    if (connectTextElement && spinnerElement && connectTextElement.innerText !== "Connected") {
        connectTextElement.style.display = 'inline-block'; // Display the text
        spinnerElement.style.display = 'inline-block'; // Display the spinner
    }

    // Make AJAX request to notify the server about the command
    fetch('/connect_device', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            udid: selectedDeviceIdentifier,
            ios_version: selectedDeviceVersion, // Include iOS version in the request
            connType: selectedDeviceConnType, //connection type USB or WIFI
            //wifiAddress: selectedDeviceWifiAddress,
            wifiState: SelectedDeviceWifiState,
        }),
    })
    .then(response => response.json())
    .then(data => {
        console.log('connect data: ', data);



        // Check if developer mode is required
        if ('developer_mode_required' in data) {
            // Display modal informing the user and providing options
            showModalDeveloperModeRequired();
            return;
        }
         // Check if there is an error with the message 'No Pair Record Found'
        if ('Error' in data && data.Error === 'No Pair Record Found') {
            // Display modal informing the user about the pair record
            showPairRecordModal();
            return;
    }

        // Check for the 'error' key in the response
        if ('error' in data) {
            // Display the error message as a popup or text on the page
            //alert(data.error); // You can use a better UI method here
            showModalTimeout();

            // Reset connectTextElement
            if (connectTextElement) {
                connectTextElement.innerText = "Connect Device";
                spinnerElement.style.display = 'none'; // Display the spinner
            }

            // Enable Connect button
            if (connectButton) {
                connectButton.disabled = false;
            }

            // Stop processing the rest of the JavaScript
            return;
        }

        // code for successful response
        var displayTextElement = document.getElementById('displayText');
        if (displayTextElement) {
            displayTextElement.innerText = data;
        }

        if (connectTextElement) {
            connectTextElement.innerText = "Connected";
        }

        if (connectButton) {
            connectButton.disabled = true;  // Disable the button
        }

        if (spinnerElement && connectTextElement.innerText === "Connected") {
            spinnerElement.style.display = 'none'; // Hide the spinner
        }

        if (deviceDropdown) {
            deviceDropdown.disabled = true;  // Disable the button
        }

            var containerElement = document.body;
            var rsdDataElement = document.getElementById('rsdData');

            if (containerElement && rsdDataElement) {
                try {
                    console.log('container data:', data);
                    //var jsonData = JSON.parse(data);


                    if ('rsd_data' in data) {
                        rsdDataElement.value = data.rsd_data;

                        if (connectTextElement && connectTextElement.innerText === "Connected") {
                            //rsdDataElement.style.display = 'block';  // Make rsdData visible
                            updateSetLocationButtonStatus();
                            updateStopLocationButtonStatus();  // Add this line to update the Stop Location button status

                            // Show the disconnect button when rsdData is visible
                            var disconnectButton = document.getElementById('disconnect');
                            if (disconnectButton) {
                                disconnectButton.style.display = 'inline-block';
                                disconnectButton.innerText = 'Disconnect';
                            }
                        }
                    } else {
                        rsdDataElement.value = 'No rsd_data found in the data';
                    }
                } catch (error) {
                    console.error('Error parsing data:', error);
                    rsdDataElement.value = 'Error parsing data';
                }

                rsdDataElement.readOnly = true;
            }
        })
        .catch(error => {
            console.error('Error connecting device:', error);
            var displayTextElement = document.getElementById('displayText');
            if (displayTextElement) {
                displayTextElement.innerText = 'Error connecting device.';
            }

            if (connectTextElement) {
                connectTextElement.innerText = "Error connecting";
            }

            if (connectButton) {
                connectButton.disabled = false;  // Enable the button
            }
        });
}


// Function to show the modal for developer mode required
function showModalDeveloperModeRequired() {
    $('#developerModeRequiredModal').modal('show');
}
// Function to show the modal for developer mode required
function showPairRecordModal() {
    $('#pairRecordModal').modal('show');
}

// Function to show the modal for developer mode required
function showModalWifiModeRequired() {
    $('#wifiModeRequiredModal').modal('show');
}


    /// Function to disconnect device
    function disconnectDevice() {
        var connectTextElement = document.getElementById('connectText');
        var connectButton = document.getElementById('connect');
        var disconnectButton = document.getElementById('disconnect');
        var deviceDropdown = document.getElementById('device');
        stopLocation();
        // Use navigator.sendBeacon to make the POST request without waiting for a response
        const data = JSON.stringify({});
        //navigator.sendBeacon('/stop_tunnel', data);
        console.log('Disconnect - Clearing');

        var setLocationButton = document.getElementById('set-location');
        var stopLocationButton = document.getElementById('stop-location');
        stopLocationButton.disabled = true;
        setLocationButton.disabled = true;

        // Enable the device dropdown
        if (deviceDropdown) {
            deviceDropdown.disabled = false;
        }

        // Update Disconnect button text and show Connect button
        if (disconnectButton) {
            disconnectButton.innerText = "Disconnecting, Please wait...";
            disconnectButton.style.display = 'none';
        }

        // Hide rsdData text box
        var rsdDataElement = document.getElementById('rsdData');
        if (rsdDataElement) {
            rsdDataElement.style.display = 'none';
        }

        // Reset connectTextElement
        if (connectTextElement) {
            connectTextElement.innerText = "Connect Device";
        }

        // Enable Connect button
        if (connectButton) {
            connectButton.disabled = false;
        }
    }



    async function handleFuelTypeChange() {
    var fuelTypeDropdown = document.getElementById('fuelType');
    var fuelText = document.getElementById('fuelText');
    var fuelRegionDropdown = document.getElementById('fuelRegion');
    const selectedFuelRegion = fuelRegionDropdown.value;
    const selectedFuelType = fuelTypeDropdown.value;
    console.log('Selected Fuel Region = ', selectedFuelRegion);
    fuelText.value = '';
    fuelTypeDropdown.innerHTML = '';

    try {
        const response = await fetch(`/api/fuel_types?region=${selectedFuelRegion}`);
        const fuelTypes = await response.json();
        fuelTypes.sort();
        fuelTypes.forEach(type => {
            var option = document.createElement('option');
            option.value = type;
            option.text = type;
            fuelTypeDropdown.add(option);
        });
        fuelTypeDropdown.value = selectedFuelType;
        updateFuelText(selectedFuelType, selectedFuelRegion);
    } catch (error) {
        console.error('Error fetching fuel types:', error);
    }
}

async function updateFuelText(selectedFuelType, selectedFuelRegion) {
    var fuelTypeDropdown = document.getElementById('fuelType');
    var fuelText = document.getElementById('fuelText');
    var fuelDataCollapse = document.getElementById('fuelDataCollapse');
    try {
        const response = await fetch(`/api/data/${selectedFuelType}?region=${selectedFuelRegion}`);
        const fuelTypeData = await response.json();
        fuelText.value = `
            Type: ${fuelTypeData.type}
            Price: ${fuelTypeData.price}
            Suburb: ${fuelTypeData.suburb}
            State: ${fuelTypeData.state}
            Lat: ${fuelTypeData.lat}
            Lng: ${fuelTypeData.lng}
        `;
        setCoordinates(fuelTypeData.lat, fuelTypeData.lng);
        handleSearch();
        fuelDataCollapse.classList.toggle('show', !!fuelTypeData);
    } catch (error) {
        console.error('Error fetching fuel type data:', error);
    }
}

function setLocationArrows() {
        fetch('/set_location', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({}),
        })
            .then(response => response.text())
            .then(data => {
                //displayToast(data); // Display response as a toast
                console.log('set_location response:', data);
            })
            .catch(error => {
                console.error('Error setting location:', error);
            });
    }


    function setLocation() {
        fetch('/set_location', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({}),
        })
            .then(response => response.text())
            .then(data => {
                displayToast(data); // Display response as a toast
                console.log('set_location response:', data);
            })
            .catch(error => {
                console.error('Error setting location:', error);
            });
    }

    function stopLocation() {
        fetch('/stop_location', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({}),
        })
            .then(response => response.text())
            .then(data => {
                displayToast(data); // Display response as a toast
                console.log('stop_location response:', data);
            })
            .catch(error => {
                console.error('Error stopping location:', error);
            });
    }

    // Function to enable or disable the Set Location button based on conditions
    function updateSetLocationButtonStatus() {
        var setLocationButton = document.getElementById('set-location');
        var rsdDataElement = document.getElementById('rsdData');
        var coordinatesInput = document.getElementById('coordinates');
        var enableButton = rsdDataElement.value.trim() !== '' && coordinatesInput.value.trim() !== '';
        setLocationButton.disabled = !enableButton;
    }

    // Function to enable or disable the Stop Location button based on conditions
    function updateStopLocationButtonStatus() {
        var stopLocationButton = document.getElementById('stop-location');
        var rsdDataElement = document.getElementById('rsdData');
        var enableButton = rsdDataElement.value.trim() !== '';
        stopLocationButton.disabled = !enableButton;
    }

    function exitApp() {
        console.log('Exit App function called');

        try {
            // Display a non-blocking modal dialog indicating server shutdown
            $('#aboutModal').modal('hide');
            $('#shutdownModal').modal('show');

            // Use navigator.sendBeacon to make the POST request without waiting for a response
            const data = JSON.stringify({});
            navigator.sendBeacon('/exit', data);
            window.open('', '_self', ''); window.close();

            console.log('POST request sent using sendBeacon');
        } catch (error) {
            console.error('Error during server shutdown:', error);
        }
    }

    function aboutApp() {
        event.preventDefault();
        var appVersion = "{{ app_version }}";
        alert("App Version: " + appVersion);
    }

    // Function to show the modal
    function showModal() {
<!--        var modal = document.getElementById('developerModeModal');-->
<!--        modal.style.display = 'block';-->
            $('#developerModeModal').modal('show');

    }

        // Function to show the modal
    function showModalTimeout() {
            $('#modalTimeout').modal('show');
    }

    // Function to close the modal
    function closeModal() {
        var modal = document.getElementById('developerModeModal');
        modal.style.display = 'none';
    }

    // Function to toast
    function toast(data) {
    const toastLiveExample = document.getElementById('liveToast')
    const toastBootstrap = bootstrap.Toast.getOrCreateInstance(toastLiveExample)
    var data = data;
    toastBootstrap.show();
  }

  function displayToast(message) {
      // Create a new toast element
      var toast = document.createElement('div');
      toast.classList.add('toast');
      toast.setAttribute('role', 'alert');
      toast.setAttribute('aria-live', 'assertive');
      toast.setAttribute('aria-atomic', 'true');

      // Set up the toast content
      toast.innerHTML = `
        <div class="toast-header">
          <strong class="mr-auto">GeoPort</strong>
          <small>Just Now</small>
          <button type="button" class="ml-2 mb-1 close" data-bs-dismiss="toast" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="toast-body">
          ${message}
        </div>
      `;

      // Append the toast to the toast container
      document.querySelector('.toast-container').appendChild(toast);

      // Initialize the toast
      var toastElement = new bootstrap.Toast(toast);

      // Show the toast
      toastElement.show();
    }

function continueAfterDeveloperModeRequired() {
    var selectedOptionValue = JSON.parse(document.getElementById('device').value);
    var selectedDeviceIdentifier = selectedOptionValue.Identifier;
    var selectedDeviceVersion = selectedOptionValue.ProductVersion;
    var connectTextElement = document.getElementById('connectText');
    var spinnerElement = document.getElementById('spinner');
    console.log('Enabling Developer Mode on: ', selectedDeviceIdentifier);

    if (connectTextElement) {
        connectTextElement.innerText = "Enabling Developer Mode";
        spinnerElement.style.display = 'inline-block'; // Hide the spinner
    }

    // Make an AJAX request to enable developer mode
    fetch('/enable_developer_mode', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            udid: selectedDeviceIdentifier,
        }),
    })
    .then(response => response.json())
    .then(data => {
        console.log('post enable dev mode fetch data: ', data);
        if (data.success) {
            // Developer mode enabled successfully
            connectDevice();
        } else if (data.error) {
            // Handle the error, e.g., display an alert or take appropriate action
            //alert(data.error);
            showAlertOrModal(data.error);
        }
    })
    .catch(error => {
        console.error('Error enabling developer mode:', error);
        // Handle the error, e.g., display an alert or take appropriate action
        //alert('Error enabling developer mode.');
        showAlertOrModal('Error enabling developer mode.');
    });
}






// Function to cancel after developer mode is required
    function cancelAfterDeveloperModeRequired() {
        var connectTextElement = document.getElementById('connectText');
        var spinnerElement = document.getElementById('spinner');
        // Perform any actions needed to cancel after developer mode is required
        // Reset connectTextElement
        if (connectTextElement) {
            connectTextElement.innerText = "Connect Device";
            spinnerElement.style.display = 'none'; // Hide the spinner
        }


        //window.location.href = '/';
        fetch('/', {
            method: 'GET',

        })

    }


    // Function to show either an alert or the developerError modal
    function showAlertOrModal(errorMessage) {
        // Check if the modal element exists
        var connectTextElement = document.getElementById('connectText');
        var spinnerElement = document.getElementById('spinner');
        // Perform any actions needed to cancel after developer mode is required
        // Reset connectTextElement
        if (connectTextElement) {
            connectTextElement.innerText = "Connect Device";
            spinnerElement.style.display = 'none'; // Hide the spinner
        }

        var developerErrorModal = document.getElementById('developerError');
        if (developerErrorModal) {
            // Set the error message in the modal
            document.getElementById('developerErrorMessage').innerText = errorMessage;
            // Show the modal
            $('#developerError').modal('show');
        } else {
            // Fallback to alert if modal element doesn't exist
            alert(errorMessage);
        }
    }




    document.addEventListener('DOMContentLoaded', function () {
    console.log("test");
    initializeMap();
    searchLocation();
    handleFuelTypeChange();
    document.getElementById('rsdData').addEventListener('change', updateSetLocationButtonStatus);
    document.getElementById('coordinates').addEventListener('input', updateSetLocationButtonStatus);
    populateDeviceList();
    updateStopLocationButtonStatus();  // Add this line to update the Stop Location button status
    // Add event listener for keydown event
    document.addEventListener('keydown', handleKeyDown);
    console.log("listener loaded");

    document.getElementById('search').addEventListener('click', handleSearch);
    
    
    
    // Add the new event listeners for 'Enter' keypress and 'Search' button click
    document.getElementById('coordinates').addEventListener('keypress', function (event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            handleSearch();
        }
    });

    



    


});
</script>

<p></p>

<div class="mb-3">
    <div class="row align-items-center">
        <div class="col-md-auto">
            <label class="mb-0" for="coordinates">Location:</label>
        </div>
        <div class="col">
            <input type="text" class="form-control" id="coordinates">
        </div>
        <div class="col-md-auto">
            <button type="button" class="btn btn-primary" id="search" onclick="handleSearch()">Search</button>
        </div>
    </div>
</div>

<div class="mb-3">
    <div class="row align-items-center">
        <div class="col">
            <button type="button" class="btn btn-primary w-100" data-toggle="popover" id="set-location" disabled onclick="setLocation()">Simulate Location</button>
        </div>
        <div class="col">
            <button type="button" class="btn btn-primary w-100" data-toggle="popover" id="stop-location" disabled onclick="stopLocation()">Stop Location</button>
        </div>
    </div>

    <!-- Centered Buy Me A Coffee button -->
    <div class="row justify-content-center">
        <div class="col-6 text-center"> <!-- Adjust the column size and add text-center class -->
            <!-- Your Buy Me A Coffee button code -->
            <p></p>
            <a href="https://www.buymeacoffee.com/davesc63">
                <img src="https://img.buymeacoffee.com/button-api/?text=Buy%20me%20a%20beer&emoji=🍺&slug=davesc63&button_colour=FFDD00&font_colour=000000&outline_colour=000000&coffee_colour=ffffff" alt="Buy me a beer">
            </a>
        </div>
    </div>
</div>
    <hr>
Version: {{ app_version_num }}<br>
Need help? Please see the <a href="https://github.com/davesc63/GeoPort/blob/main/FAQ.md" target="_blank">FAQ</a><br>
Feedback? Please see the <a href="https://www.surveymonkey.com/r/5LJR2M5" target="_blank">Survey</a>





<div class="modal fade" id="shutdownModal" tabindex="-1" role="dialog" aria-labelledby="shutdownModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="shutdownModalLabel">Server Shutdown</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                Thank you for using the app!
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="aboutModal" tabindex="-1" role="dialog" aria-labelledby="aboutModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="aboutModalLabel">GeoPort</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                App Version: {{ app_version }}
            </div>
        </div>
    </div>
</div>


<div class="modal fade" id="developerModeModal" tabindex="-1" role="dialog" aria-labelledby="devModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="developerModeModal">Developer Mode</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>The device is enabled with a passcode </p>
                Developer Mode is required and cannot be enabled
                <p>Please temporarily disable your passcode and</p>
                try to connect again
                <p>Enabling Developer Mode is only required one-time.</p>
            </div>
            <div class="modal-footer d-flex justify-content-center">
                <button type="button" class="btn btn-secondary mx-auto" data-bs-dismiss="modal" onclick="window.location.href = '/'">OK</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="pairRecordModal" tabindex="-1" role="dialog" aria-labelledby="pairRecordModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="pairRecordModalLabel">No Pair Record</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Pair Record Not Found</p>
                Please use a USB Cable to create a Pair Record

            </div>
            <div class="modal-footer justify-content-center">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="window.location.href = '/'">OK</button>

            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="developerModeRequiredModal" tabindex="-1" role="dialog" aria-labelledby="developerModeRequiredModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="developerModeRequiredModalLabel">Developer Mode Required</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <p>Developer mode is not enabled</p>
                GeoPort will now attempt to enable Developer Mode
                <p>Your device will reboot</p>
                OK to proceed<br>
                Cancel to return home
            </div>
            <div class="modal-footer justify-content-center">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="continueAfterDeveloperModeRequired()">OK</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="cancelAfterDeveloperModeRequired()">Cancel</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="modalTimeout" tabindex="-1" role="dialog" aria-labelledby="modalTimeout" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="modalTimeout">Connect Timeout</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body text-center">
                <p>Unable to create device tunnel within 60 seconds</p>

                <p>Please try to connect again</p>

            </div>
            <div class="modal-footer d-flex justify-content-center">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="window.location.href = '/'">Close</button>

            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="developerError" tabindex="-1" role="dialog" aria-labelledby="developerErrorLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="developerErrorLabel">Developer Error</h5>
                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body text-center">
                <p id="developerErrorMessage"></p>
            </div>
            <div class="modal-footer d-flex justify-content-center">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" onclick="window.location.href = '/'">Close</button>
            </div>
        </div>
    </div>
</div>




<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <div id="liveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="toast-header">
      <strong class="me-auto">GeoPort</strong>
      <small>Just Now</small>
      <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
    </div>
    <div class="toast-body">
        {{ data }}
    </div>
  </div>
</div>
<!-- Toast Container -->
  <div aria-live="polite" aria-atomic="true" style="position: relative; min-height: 200px;">
    <div class="toast-container position-absolute top-0 end-0 p-3" style="z-index: 9999;"></div>
  </div>

</div>

</body>

</html>